ctmc

// --- CONSTANTS ---
// Configuration
const NUMBER_OF_URL_REQUESTS;
const MAX_QUEUE = NUMBER_OF_URL_REQUESTS + 1;

// DNS Parameters
const double popularity;
const query_id_range = 65536;
const port_id_range;

// Rates
const guess;
const double requests_rate = 1;
const other_legitimate_requests_rate;

// --- FORMULAS ---
formula cache_poisoned = (correct_guess = true);

// --- MODULES ---
module intruder_machine
	// -- States
	trials : [0..NUMBER_OF_URL_REQUESTS] init 0;
	resolver_replies : [0..NUMBER_OF_URL_REQUESTS] init 0;

	// -- Transitions
	// 1. Send Request: Initiates resolution.
	[DNS_Request_Client_To_Resolver] trials < NUMBER_OF_URL_REQUESTS -> requests_rate : (trials' = trials + 1);

	// 2. Receive Reply: Marks end of query cycle.
	[DNS_Response_Resolver_To_Client] resolver_replies < trials -> (resolver_replies' = resolver_replies + 1);

	// 3. Termination
	[] resolver_replies = NUMBER_OF_URL_REQUESTS -> true;
endmodule

module victim_resolver 
	// -- States
	ttl : [0..2] init 2;
	client_queue : [0.. MAX_QUEUE] init 0;
	root_queue : [0.. MAX_QUEUE] init 0;
	domain_queue : [0.. MAX_QUEUE] init 0;
	responses_queue : [0.. MAX_QUEUE] init 0;

	// -- Variables
	query_to_root_server: bool init false;
	query_to_domain_server: bool init false;
	answer_from_domain_received: bool init false;
	correct_guess: bool init false;

	// -- Transitions
	// 1. Client Request (Merged Hit/Miss Logic)
	[DNS_Request_Client_To_Resolver] (client_queue < MAX_QUEUE) & (responses_queue < MAX_QUEUE) & (root_queue < MAX_QUEUE) -> 
    		// Branch 1: Cache Hit
    		(popularity / 10) : (client_queue' = client_queue + 1) & (ttl' = 1) & (responses_queue' = responses_queue + 1)
    		+
    		// Branch 2: Cache Miss
    		(1 - (popularity / 10)) : (client_queue' = client_queue + 1) & (ttl' = 0) & (root_queue' = root_queue + 1);
	
	// 2. Query Root
	[DNS_Request_Resolver_To_Root] (client_queue > 0) & (root_queue > 0) 
		-> (query_to_root_server' = true);

	// 3. Root Responds -> Move to Domain Queue
	[DNS_Response_Root_To_Resolver] (root_queue > 0) & (domain_queue < MAX_QUEUE)
 		-> (root_queue' = root_queue - 1) & (domain_queue' = domain_queue + 1) & (query_to_root_server' = false);

	// 4. Query Domain (Opens Vulnerability Window)
	[DNS_Request_Resolver_To_Domain] domain_queue > 0 -> (query_to_domain_server' = true);

	// 5. Domain Responds (Closes Window)
	[DNS_Response_Domain_To_Resolver] (domain_queue > 0) & (responses_queue < MAX_QUEUE) & (correct_guess = false) 
		-> (domain_queue' = domain_queue - 1) & (responses_queue' = responses_queue + 1) & (query_to_domain_server' = false) & (answer_from_domain_received' = true);
	
	// 6. Reply to Client
	[DNS_Response_Resolver_To_Client] (responses_queue > 0) & (client_queue > 0) 
		-> (client_queue' = client_queue - 1) & (responses_queue' = responses_queue - 1);
	

	// --- Race Condition (Attack) ---
	[Guess] (correct_guess = false) & (query_to_domain_server = true) -> 
        	1 / (query_id_range * port_id_range) : (correct_guess'=true)
		+
		((query_id_range * port_id_range) - 1) / (query_id_range * port_id_range): (correct_guess'=false);
	
	// Sink State
	[] cache_poisoned = true -> true;
endmodule

module root_server
	// States
	root_state : [0..1] init 0;

	// Transitions

	// 1. Receive Request: A query arrives from the Victim Resolver.
	[DNS_Request_Resolver_To_Root] root_state = 0 -> (root_state' = 1);

	// 2. Send Reply: The Root Server immediately responds, moving the resolver to the next step (Domain Server).
	[DNS_Response_Root_To_Resolver] root_state = 1 -> (root_state' = 0);
endmodule

module target_domain_server
	// -- States
	domain_state : [0..1] init 0;
	
	// -- Transitions
	// 1. Receive Request: The Victim Resolver asks "Where is example.com?".
    	// This opens the 'Race Window'. The Intruder starts guessing NOW.
	[DNS_Request_Resolver_To_Domain] domain_state = 0 -> (domain_state' = 1);

	// 2. Legitimate Response (The "Good" Ending):
    	// The server processes the specific request from our Victim Resolver.
        // This transition closes the 'Race Window' (Intruder stops guessing).
	[DNS_Response_Domain_To_Resolver] domain_state = 1 -> 1/(other_legitimate_requests_rate) : (domain_state' = 0);

	// 3. Busy Work ("Noise"):
    	// The server is busy answering OTHER users on the internet.
    	// This keeps the server in state 1 (busy), effectively delaying the response to our Victim.
	[DNS_Response_Domain_Other_Request] domain_state = 1 -> (other_legitimate_requests_rate - 1)/other_legitimate_requests_rate : (domain_state' = 1);
endmodule

module intruder_server
	// -- States
	is_state : [0..1] init 0;
	
	// -- Transitions
	// 1. Start Attack: Triggered when the Victim Resolver queries the Domain Server.
    	// The 'Race Window' is now open.
	[DNS_Request_Resolver_To_Domain] is_state = 0 -> (is_state' = 1);

	// 2. Firing Loop (The "Machine Gun"):
    	// Fires guesses at rate 'guess'.
    	// The success/failure logic is handled by the Victim Resolver module via probabilistic split.
	[Guess] is_state = 1 -> guess : (is_state' = 1);

	// 3. Stop Attack: Triggered when the Victim Resolver receives the legitimate answer.
    	// The 'Race Window' is closed. The attack failed for this specific query.
	[DNS_Response_Domain_To_Resolver] is_state = 1 -> (is_state' = 0);
endmodule