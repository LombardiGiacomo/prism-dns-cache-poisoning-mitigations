ctmc
const NUMBER_OF_URL_REQUESTS;			// Number of URL requests the IM sends to the Resolver = Number of Cache-Poisoning Attacks launched by the attacker
const MAX_QUEUE_IN_CS=NUMBER_OF_URL_REQUESTS+1; // Total requests the IM can send + 1, to ensure that the queue is never full.
const double popularity;			// Popularity is related to the probability of a requested url to be cached in CS's cache. Higher popularity => higher probability for a url to be cached.
const number_of_query_ids=65536;		// Number of possible query IDs is 2^16
const number_of_port_ids;			// number_of_port_ids = 1, port id is fixed. number_of_port_ids > 1, port id has a random value between 1 and number_of_port_ids.
const guess;					// Rate at which the AS tries to guess the response. Higher guess rate more guesses arrive at the CS.
const double requests_rate = 1;			// Rate at which the IM sends requests to the CS. It is always set to 1, does not affect the results.
const other_legitimate_requests_rate;		// Rate at which requests from legitimate users arrive at the DS. Higher other_legitimate_requests_rate refers to more work load for the DS. Therefore, more guesses can be done by the AS.
const threshold = 5;				// Number of maximum packets before mitigation starts
const reset_window_rate = 1;			// Rate of 1/W to model the fact that after a temporal window of W seconds, suspicious count is reset

formula cache_poisoned = correct_guess=true;	// Formula cache_poisoned is true if the AS guesses correctly (cache is poisoned).

// Module of the Intruder's machine (IM). IM sends a number of requests for a url.
module intruder_machine
	trials : [0..NUMBER_OF_URL_REQUESTS] init 0;	// Number of requests that IM can send to CS.
	answers_received : [0..NUMBER_OF_URL_REQUESTS] init 0;	// Number of replies received by IM

	// -- Transitions
	[client_request_to_cs] trials<NUMBER_OF_URL_REQUESTS ->  requests_rate : (trials'=trials+1);	// 1) IM requests a URL resolution. 
	[cs_response_to_client] answers_received<trials -> (answers_received'=answers_received+1);		// 2) IM receives a reply.
	[] answers_received=NUMBER_OF_URL_REQUESTS -> true;	// END MODEL condition if all the requests are answered.
endmodule

module client_server // Victim Resolver
	ttl : [0..2] init 2;					// TTL=0 means response not in cache; TTL=1 means response in cache (immediate answer)
	query_domain_server : bool init false;			// true when a query is made to DS
	query_root_server : bool init false;			// true when a query is made to RS
	clients_requests_queue : [0.. MAX_QUEUE_IN_CS] init 0;	// queue of requests from clients (IM or normal client=CM) to be resolved.
	rs_queue : [0.. MAX_QUEUE_IN_CS] init 0;		// queue of requests waiting to be forwarded to the RS.
	ds_queue : [0.. MAX_QUEUE_IN_CS] init 0;		// queue of requests waiting to be forwarded to the DS.
	responses_queue: [0.. MAX_QUEUE_IN_CS] init 0;		// queue of the answered requests that the CS has to forward to the clients.
 	correct_guess : bool init false;			// becomes true if the AS guesses correctly the query ID and port ID.
	answer_from_domain_received : bool init false;		// The answer from the DS is received
	suspicious_count : [0..threshold] init 0;		// number of DNS responses that deffer from each other only in query id or port id
	mitigation_active : bool init false;			// detection module has activated the mitigation (TC flage set to 1)

	// -- Transitions
	// 1) Receive request from client (IM or CM). 
	[client_request_to_cs] clients_requests_queue<MAX_QUEUE_IN_CS & responses_queue<MAX_QUEUE_IN_CS & rs_queue<MAX_QUEUE_IN_CS ->
	// With rate "popularity", ttl gets value of 1, which means that the requested url exists in CS's cache. If the url is cached, then the queue of the answered queries (responses_queue) is increased by one, so that the server can answer back to the client.
	(popularity/10) : (clients_requests_queue'=clients_requests_queue+1) & (ttl'=1) & (responses_queue'=responses_queue+1)
	+
	// With rate "1-popularity", ttl=0, to show that the requested url does not exist in cache. If the url is not cached, then the query resolution proccess begins, by increasing the RS queue (rs_queue) by one.
	(1 - popularity/10) : (clients_requests_queue'=clients_requests_queue+1) & (ttl'=0) & (rs_queue'=rs_queue+1);

	// 2) If the requested URL does not exist in the resolver's cache (ttl=0), then issue a query to the RS
	[cs_request_to_rs] clients_requests_queue>0 & rs_queue>0 ->(query_root_server'=true);

	// 3) When RS replies, the answer has to be forwarded to DS. The RS queue has to be reduced by one and the DS queue is increased by one.
	[rs_response_to_cs] rs_queue>0 & ds_queue<MAX_QUEUE_IN_CS -> (rs_queue'=rs_queue-1) & (ds_queue'=ds_queue+1) & (query_root_server'=false);

	// 4) Query is issued to the DS 
	[cs_request_to_ds] ds_queue>0 -> (query_domain_server'=true);
	
	// 5) When DS replies, an answer has to be forwarded to a client and the DS queue has to be reduced by one.
	[ds_response_to_cs] ds_queue>0 & responses_queue<MAX_QUEUE_IN_CS & correct_guess=false -> 
	(ds_queue'=ds_queue-1) & (responses_queue'=responses_queue+1) & (query_domain_server'=false) & (answer_from_domain_received'=true);

	// 6) Reply to client, and remove the query from the queue of queries received from clients, as well as from the queries answered queue too.
	[cs_response_to_client] responses_queue>0 & clients_requests_queue>0 -> (clients_requests_queue'=clients_requests_queue-1) & (responses_queue'=responses_queue-1);

	// 7) Receive a guess from AS.
	[Guess] correct_guess=false & query_domain_server=true & mitigation_active=false & suspicious_count<threshold-> 
	// With rate 1/(query_id*port_id) a correct guess will arrive to the CS. Total Rate = (1/query_id*port_id) * (guess).
	1/(number_of_query_ids*number_of_port_ids) : (correct_guess'=true)
	+
	// With rate query_id*port_id-1 a false guess arrives at the CS. Total Rate = (query_id*port_id-1) * (guess).
	(number_of_query_ids*number_of_port_ids-1)/(number_of_query_ids*number_of_port_ids) : (correct_guess'=false) 
	& (suspicious_count'=suspicious_count+1);

	// If the cache poisong attack is successful, then a final state for the model is reached.
	[] cache_poisoned=true -> true;

	// If threshold suspicious packets arrived, mitigation is activated
	[Activate_Mitigation] suspicious_count=threshold -> (mitigation_active'=true);	

	// Reset of suspicious count according to Reset Window Rate
	//[] suspicious_count>0 & mitigation_active=false -> reset_window_rate : (suspicious_count'=0);
	
endmodule

module root_server
	rs_state : [0..1] init 0;	// srs_tate = 0 --> wait for request; rs_state = 1 --> answer request.

	// -- Transitions
	// 1) Receive reply from CS.
	[cs_request_to_rs] rs_state=0 -> (rs_state'=1);
	
	// 2) Reply to CS.
	[rs_response_to_cs] rs_state=1 -> (rs_state'=0);
endmodule

module target_domain_server
	ds_state : [0..1];	// ds_state = 0 --> wait for request; ds_state = 1 --> answer request.
	denial_of_service : bool init false;

	// -- Transitions
	// 1) Receive request from CS. 
	[cs_request_to_ds] ds_state=0 -> (ds_state'=1);

	// 2) Reply to arriving requests from DS
	// Rate to apply to CS's request is related with the workload for the DS. Therefore the rate is 1/(other_legitimate_requests_rate).
	[ds_response_to_cs] ds_state=1 -> 1/(other_legitimate_requests_rate) : (ds_state'=0);
	// 3) Manage requests from other legitiamete users on the Internet.
	// Rate to apply to one of all the other requests from legitimate users is (other_legitimate_requests_rate-1)/other_legitimate_requests_rate.
	[serve_other_request] ds_state=1 -> (other_legitimate_requests_rate-1)/other_legitimate_requests_rate : (ds_state'=1);
endmodule

module intruder_server
	is_state : [0..1] init 0;	// is_state = 0 --> wait for Resolver to forward request to DS; is_state = 1 --> guess response
	
	// -- Transitions
	// 1) The Resolver forward the request to the DS => Start attack
	[cs_request_to_ds] is_state=0 -> (is_state'=1);
	
	// 2) Try to guess the answer by guessing the values for query id and port id. Rate for guess requests is "guess".
	[Guess] is_state=1 -> guess : (is_state'=1);	
	
	// 3) The DS replies to the Resolver, ten the attack fails.
	[ds_response_to_cs] is_state=1 -> (is_state'=0);
endmodule
